<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.timegarage.works</id>
    <title>少数派报告</title>
    <updated>2020-09-20T07:54:40.180Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.timegarage.works"/>
    <link rel="self" href="https://www.timegarage.works/atom.xml"/>
    <subtitle>Minority Report</subtitle>
    <logo>https://www.timegarage.works/images/avatar.png</logo>
    <icon>https://www.timegarage.works/favicon.ico</icon>
    <rights>All rights reserved 2020, 少数派报告</rights>
    <entry>
        <title type="html"><![CDATA[React设计思想]]></title>
        <id>https://www.timegarage.works/post/React-Design-Philosophy/</id>
        <link href="https://www.timegarage.works/post/React-Design-Philosophy/">
        </link>
        <updated>2020-09-11T01:43:16.000Z</updated>
        <summary type="html"><![CDATA[<center>转载文章：https://github.com/react-guide/react-basic</center>]]></summary>
        <content type="html"><![CDATA[<center>转载文章：https://github.com/react-guide/react-basic</center>
<!-- more -->
<h1 id="react-设计思想">React 设计思想</h1>
<blockquote>
<p>译者序：本文是 React 核心开发者、有 React API 终结者之称的 Sebastian Markbåge 撰写，阐述了他设计 React 的初衷。阅读此文，你能站在更高的高度思考 React 的过去、现在和未来。原文地址：https://github.com/reactjs/react-basic</p>
</blockquote>
<p>我写此文是想正式地阐述我心中 React 的<a href="http://baike.baidu.com/view/2333986.htm">心智模型</a>。目的是解释为什么我们会这样设计 React，同时你也可以根据这些论点反推出 React。</p>
<p>不可否认，此文中的部分论据或前提尚存争议，而且部分示例的设计可能存在 bug 或疏忽。这只是正式确定它的最初阶段。如果你有更好的完善它的想法可以随时提交 pull request。本文不会介绍框架细节中的奇技淫巧，相信这样能提纲挈领，让你看清 React 由简单到复杂的设计过程。</p>
<p>React.js 的真实实现中充满了具体问题的解决方案，渐进式的解法，算法优化，历史遗留代码，debug 工具以及其他一些可以让它真的具有高可用性的内容。这些代码可能并不稳定，因为未来浏览器的变化和功能权重的变化随时面临改变。所以具体的代码很难彻底解释清楚。</p>
<p>我偏向于选择一种我能完全 hold 住的简洁的心智模型来作介绍。</p>
<h2 id="变换transformation">变换（Transformation）</h2>
<p>设计 React 的核心前提是认为 UI 只是把数据通过映射关系变换成另一种形式的数据。同样的输入必会有同样的输出。这恰好就是纯函数。</p>
<pre><code class="language-js">function NameBox(name) {
  return { fontWeight: 'bold', labelContent: name };
}
</code></pre>
<pre><code>'Sebastian Markbåge' -&gt;
{ fontWeight: 'bold', labelContent: 'Sebastian Markbåge' };
</code></pre>
<h2 id="抽象abstraction">抽象（Abstraction）</h2>
<p>你不可能仅用一个函数就能实现复杂的 UI。重要的是，你需要把 UI 抽象成多个隐藏内部细节，又可复用的函数。通过在一个函数中调用另一个函数来实现复杂的 UI，这就是抽象。</p>
<pre><code class="language-js">function FancyUserBox(user) {
  return {
    borderStyle: '1px solid blue',
    childContent: [
      'Name: ',
      NameBox(user.firstName + ' ' + user.lastName)
    ]
  };
}
</code></pre>
<pre><code>{ firstName: 'Sebastian', lastName: 'Markbåge' } -&gt;
{
  borderStyle: '1px solid blue',
  childContent: [
    'Name: ',
    { fontWeight: 'bold', labelContent: 'Sebastian Markbåge' }
  ]
};
</code></pre>
<h2 id="组合composition">组合（Composition）</h2>
<p>为了真正达到重用的特性，只重用叶子然后每次都为他们创建一个新的容器是不够的。你还需要可以包含其他抽象的容器再次进行组合。我理解的“组合”就是将两个或者多个不同的抽象合并为一个。</p>
<pre><code class="language-js">function FancyBox(children) {
  return {
    borderStyle: '1px solid blue',
    children: children
  };
}

function UserBox(user) {
  return FancyBox([
    'Name: ',
    NameBox(user.firstName + ' ' + user.lastName)
  ]);
}
</code></pre>
<h2 id="状态state">状态（State）</h2>
<p>UI 不单单是对服务器端或业务逻辑状态的复制。实际上还有很多状态是针对具体的渲染目标。举个例子，在一个 text field 中打字。它不一定要复制到其他页面或者你的手机设备。滚动位置这个状态是一个典型的你几乎不会复制到多个渲染目标的。</p>
<p>我们倾向于使用不可变的数据模型。我们把可以改变 state 的函数串联起来作为原点放置在顶层。</p>
<pre><code class="language-js">function FancyNameBox(user, likes, onClick) {
  return FancyBox([
    'Name: ', NameBox(user.firstName + ' ' + user.lastName),
    'Likes: ', LikeBox(likes),
    LikeButton(onClick)
  ]);
}

// 实现细节

var likes = 0;
function addOneMoreLike() {
  likes++;
  rerender();
}

// 初始化

FancyNameBox(
  { firstName: 'Sebastian', lastName: 'Markbåge' },
  likes,
  addOneMoreLike
);
</code></pre>
<p><em>注意：本例更新状态时会带来副作用（addOneMoreLike 函数中）。我实际的想法是当一个“update”传入时我们返回下一个版本的状态，但那样会比较复杂。此示例待更新</em></p>
<h2 id="memoization">Memoization</h2>
<p>对于纯函数，使用相同的参数一次次调用未免太浪费资源。我们可以创建一个函数的 memorized 版本，用来追踪最后一个参数和结果。这样如果我们继续使用同样的值，就不需要反复执行它了。</p>
<pre><code class="language-js">function memoize(fn) {
  var cachedArg;
  var cachedResult;
  return function(arg) {
    if (cachedArg === arg) {
      return cachedResult;
    }
    cachedArg = arg;
    cachedResult = fn(arg);
    return cachedResult;
  };
}

var MemoizedNameBox = memoize(NameBox);

function NameAndAgeBox(user, currentTime) {
  return FancyBox([
    'Name: ',
    MemoizedNameBox(user.firstName + ' ' + user.lastName),
    'Age in milliseconds: ',
    currentTime - user.dateOfBirth
  ]);
}
</code></pre>
<h2 id="列表lists">列表（Lists）</h2>
<p>大部分 UI 都是展示列表数据中不同 item 的列表结构。这是一个天然的层级。</p>
<p>为了管理列表中的每一个 item 的 state ，我们可以创造一个 Map 容纳具体 item 的 state。</p>
<pre><code class="language-js">function UserList(users, likesPerUser, updateUserLikes) {
  return users.map(user =&gt; FancyNameBox(
    user,
    likesPerUser.get(user.id),
    () =&gt; updateUserLikes(user.id, likesPerUser.get(user.id) + 1)
  ));
}

var likesPerUser = new Map();
function updateUserLikes(id, likeCount) {
  likesPerUser.set(id, likeCount);
  rerender();
}

UserList(data.users, likesPerUser, updateUserLikes);
</code></pre>
<p><em>注意：现在我们向 FancyNameBox 传了多个不同的参数。这打破了我们的 memoization 因为我们每次只能存储一个值。更多相关内容在下面。</em></p>
<h2 id="连续性continuations">连续性（Continuations）</h2>
<p>不幸的是，自从 UI 中有太多的列表，明确的管理就需要大量的重复性样板代码。</p>
<p>我们可以通过推迟一些函数的执行，进而把一些模板移出业务逻辑。比如，使用“柯里化”（JavaScript 中的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"><code>bind</code></a>）。然后我们可以从核心的函数外面传递 state，这样就没有样板代码了。</p>
<p>下面这样并没有减少样板代码，但至少把它从关键业务逻辑中剥离。</p>
<pre><code class="language-js">function FancyUserList(users) {
  return FancyBox(
    UserList.bind(null, users)
  );
}

const box = FancyUserList(data.users);
const resolvedChildren = box.children(likesPerUser, updateUserLikes);
const resolvedBox = {
  ...box,
  children: resolvedChildren
};
</code></pre>
<h2 id="state-map">State Map</h2>
<p>之前我们知道可以使用组合避免重复执行相同的东西这样一种重复模式。我们可以把执行和传递 state 逻辑挪动到被复用很多的低层级的函数中去。</p>
<pre><code class="language-js">function FancyBoxWithState(
  children,
  stateMap,
  updateState
) {
  return FancyBox(
    children.map(child =&gt; child.continuation(
      stateMap.get(child.key),
      updateState
    ))
  );
}

function UserList(users) {
  return users.map(user =&gt; {
    continuation: FancyNameBox.bind(null, user),
    key: user.id
  });
}

function FancyUserList(users) {
  return FancyBoxWithState.bind(null,
    UserList(users)
  );
}

const continuation = FancyUserList(data.users);
continuation(likesPerUser, updateUserLikes);
</code></pre>
<h2 id="memoization-map">Memoization Map</h2>
<p>一旦我们想在一个 memoization 列表中 memoize 多个 item 就会变得很困难。因为你需要制定复杂的缓存算法来平衡调用频率和内存占有率。</p>
<p>还好 UI 在同一个位置会相对的稳定。相同的位置一般每次都会接受相同的参数。这样以来，使用一个集合来做 memoization 是一个非常好用的策略。</p>
<p>我们可以用对待 state 同样的方式，在组合的函数中传递一个 memoization 缓存。</p>
<pre><code class="language-js">function memoize(fn) {
  return function(arg, memoizationCache) {
    if (memoizationCache.arg === arg) {
      return memoizationCache.result;
    }
    const result = fn(arg);
    memoizationCache.arg = arg;
    memoizationCache.result = result;
    return result;
  };
}

function FancyBoxWithState(
  children,
  stateMap,
  updateState,
  memoizationCache
) {
  return FancyBox(
    children.map(child =&gt; child.continuation(
      stateMap.get(child.key),
      updateState,
      memoizationCache.get(child.key)
    ))
  );
}

const MemoizedFancyNameBox = memoize(FancyNameBox);
</code></pre>
<h2 id="代数效应algebraic-effects">代数效应（Algebraic Effects）</h2>
<p>多层抽象需要共享琐碎数据时，一层层传递数据非常麻烦。如果能有一种方式可以在多层抽象中快捷地传递数据，同时又不需要牵涉到中间层级，那该有多好。React 中我们把它叫做“context”。</p>
<p>有时候数据依赖并不是严格按照抽象树自上而下进行。举个例子，在布局算法中，你需要在实现他们的位置之前了解子节点的大小。</p>
<p>现在，这个例子有一点超纲。我会使用 <a href="http://math.andrej.com/eff/">代数效应</a> 这个由我发起的 <a href="https://esdiscuss.org/topic/one-shot-delimited-continuations-with-effect-handlers">ECMAScript 新特性提议</a>。如果你对函数式编程很熟悉，它们 在避免由 monad 强制引入的仪式一样的编码。</p>
<pre><code class="language-js">function ThemeBorderColorRequest() { }

function FancyBox(children) {
  const color = raise new ThemeBorderColorRequest();
  return {
    borderWidth: '1px',
    borderColor: color,
    children: children
  };
}

function BlueTheme(children) {
  return try {
    children();
  } catch effect ThemeBorderColorRequest -&gt; [, continuation] {
    continuation('blue');
  }
}

function App(data) {
  return BlueTheme(
    FancyUserList.bind(null, data.users)
  );
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Logstash快速入门]]></title>
        <id>https://www.timegarage.works/post/LogParsing/</id>
        <link href="https://www.timegarage.works/post/LogParsing/">
        </link>
        <updated>2020-07-13T08:27:44.000Z</updated>
        <summary type="html"><![CDATA[<center>最近在网络流量分析项目中需要对日志进行收集和处理，而网络上关于Logstash的资料都比较分散，因此本文对Logstash的架构与用法进行了简单地梳理，帮助初学者快速入门。</center>]]></summary>
        <content type="html"><![CDATA[<center>最近在网络流量分析项目中需要对日志进行收集和处理，而网络上关于Logstash的资料都比较分散，因此本文对Logstash的架构与用法进行了简单地梳理，帮助初学者快速入门。</center>
<!-- more -->
<h2 id="简介">简介</h2>
<p>Logstash是开源的服务器端数据处理管道，能够同时从多个来源采集数据，处理数据和转发数据。</p>
<h2 id="工作流程">工作流程</h2>
<p>数据输入 &gt; 数据过滤 &gt; 数据输出</p>
<h2 id="关键组件">关键组件</h2>
<p>Logstash使用input，filter，output三个组件分别完成数据采集、处理和转发的工作。</p>
<p><b>input组件负责采集数据各种格式、大小和来源的数据。</b>input组件能够以连续流式传输的方式，轻松地从日志、指标、Web应用、数据存储以及各种AWS服务采集数据。</p>
<p><b>filter插件负责动态地转换和解析数据，不受格式或复杂度的影响。</b>Grok插件可以帮助开发者方便地从非结构化数据中解析出结构化数据。</p>
<p><b>output插件负责转发filter处理过的数据到指定的数据库中。</b>Logstash提供了众多的输出选择，开发者可以将数据发送到指定的地方。例如，可以用elasticsearch插件输出到es ，rediss插件输出到redis，stdout插件标准输出，kafka插件输出到kafka等。</p>
<p>此外，Logstash具有高度的可扩展性，开发者可以根据自身需要定制插件。</p>
<h2 id="grok">Grok</h2>
<p>Grok是Logstash最重要的插件之一，使用正则表达式对数据完成过滤和解析工作。</p>
<p>参考资料：<a href="https://blog.csdn.net/qq_34021712/article/details/79746413">Logstash Grok插件语法介绍 </a></p>
<h2 id="filebeat">Filebeat</h2>
<p>Filebeat是用来替代Logstash Forwarder的下一代Logstash收集器，与Logstash相比更加轻量和高效，它可以很方便地与Logstash或Elasticsearch进行对接。</p>
<p><b>Filebeat 与 Logstash的联系与区别：</b></p>
<p><b>联系：</b>Filebeat和Logstash都具有日志收集的功能</p>
<p><b>区别：</b>Filebeat更轻量，占用资源较Logstash更少。Logstash具备过滤和处理数据的功能，但Filebeat只能采集日志。</p>
<p>在实际使用中，通常使用Filebeat作为数据收集的工具，接着使用Redis/ Kafka / RabbitMQ等缓存数据，最后将数据输出到Logstash完成数据聚合、处理的工作。</p>
]]></content>
    </entry>
</feed>